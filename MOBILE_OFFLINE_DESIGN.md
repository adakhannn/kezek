# Дизайн базового оффлайн‑режима для мобильного приложения (MOB-2)

Цель: дать пользователю **минимально полезный функционал без сети**, не ломая текущую архитектуру.

---

## 1. Что должно работать оффлайн

При отсутствии сети мобильное приложение должно позволять:

1. **Просматривать свои брони (read‑only):**
   - предстоящие и прошедшие записи из последней успешной синхронизации;
   - базовые данные: дата/время, филиал, услуга, мастер, статус.
2. **Быстро увидеть статус смены (для сотрудника):**
   - есть ли сегодня открытая смена;
   - краткая сводка по последней смене (дата, выручка, доля).

Все **изменяющие операции** (создание/отмена брони, открытие/закрытие смены и т.п.) в оффлайне:
- либо явно запрещены с понятным сообщением,
- либо ставятся в очередь синхронизации (как уже сделано для staff‑смен).

---

## 2. Структура локального кеша

Рекомендуемое хранилище: `AsyncStorage`/`SecureStore` (в зависимости от текущего стека).

### 2.1. Ключи кеша

- `offline:bookings:<userId>` — список броней пользователя.
- `offline:lastSyncAt:<userId>` — отметка времени последней успешной синхронизации броней.
- Дополнительно (если нужно):
  - `offline:staffShiftSummary:<userId>` — краткая сводка по последней смене.

### 2.2. Формат данных

Упрощённый DTO (независимый от конкретных API):

```ts
type OfflineBooking = {
  id: string;
  status: 'hold' | 'confirmed' | 'paid' | 'cancelled' | 'no_show';
  start_at: string;
  end_at: string;
  branch_name?: string | null;
  service_name?: string | null;
  staff_name?: string | null;
  created_at: string;
};

type OfflineBookingsPayload = {
  userId: string;
  updatedAt: string; // ISO
  items: OfflineBooking[];
};
```

---

## 3. Синхронизация броней

### 3.1. Когда синхронизировать

- При запуске приложения (после успешного логина / обновления токена).
- При заходе на экран “Мои записи / история”.
- При явном pull‑to‑refresh на экране броней.

### 3.2. Откуда брать данные

Варианты:

1. **Через web‑API** (предпочтительно для унификации логики и RLS):
   - добавить/использовать endpoint вида `GET /api/cabinet/bookings`:
     - возвращает список броней по `auth.uid()` с минимальным набором полей;
     - желательно уже в DTO‑формате, близком к `OfflineBooking`.
2. **Напрямую через Supabase**:
   - выборка из `bookings` с `client_id = auth.uid()` и джойнами к `branches/services/staff`;
   - маппинг в `OfflineBooking` на стороне мобилки.

### 3.3. Алгоритм синхронизации

1. Проверить наличие сети (через `NetInfo` или аналог).
2. Если сеть есть:
   - сделать запрос к API / Supabase;
   - при успехе:
     - преобразовать результат к массиву `OfflineBooking`;
     - сохранить в `offline:bookings:<userId>`;
     - обновить `offline:lastSyncAt:<userId>`.
3. Если сети нет или запрос упал:
   - не трогать кеш;
   - отобразить данные из кеша (если есть) + показать баннер/текст “Показаны данные из последней синхронизации от <дата>”.

---

## 4. UI‑поведение при оффлайне

### 4.1. Экран “Мои записи”

- При входе:
  - если сети нет → сразу читаем кеш и показываем список;
  - если сеть есть → пробуем синхронизировать, затем обновляем список.
- Визуальные элементы:
  - баннер “Нет подключения к интернету — показаны сохранённые данные”;
  - дата последней синхронизации (если есть).
- Действия:
  - **Создать новую запись**:
    - либо скрыть кнопку, либо при нажатии показать диалог “Для создания записи нужно подключение к интернету”.
  - **Отменить запись**:
    - не выполнять оффлайн (чтобы избежать конфликтов); при попытке:
      - показать сообщение “Нужно подключение к интернету для отмены”.

### 4.2. Экран смен/финансов сотрудника

Так как уже есть оффлайн‑очередь для смен:

- состояние “текущая смена” и список клиентов синхронизируются через существующий механизм;
- при отсутствии сети:
  - показывать локально сохранённые данные по смене;
  - явно отображать индикатор “данные не синхронизированы” при наличии элементов в очереди.

---

## 5. Обработка конфликтов

Базовый оффлайн‑режим для броней делаем **только read‑only**, поэтому:

- конфликты (например, бронь отменена с другого устройства или через WhatsApp) решаются при следующей синхронизации:
  - локально сохранённый статус просто перезаписывается актуальным с сервера;
  - пользователю можно коротко указать, что “некоторые записи были обновлены”.

Для изменений (смены, клиенты смены) конфликт‑резолвинг уже реализован в логике очереди (см. существующий дизайн оффлайна для staff).

---

## 6. Минимальный план внедрения

1. Добавить/уточнить API для получения списка броней клиента в компактном формате (web‑API или Supabase‑запрос).
2. На стороне мобилки:
   - реализовать слой `offlineBookingsStorage` (чтение/запись в AsyncStorage/SecureStore);
   - добавить хук/сервис `useOfflineBookings`, который:
     - при наличии сети синхронизирует и обновляет локальный кэш,
     - при отсутствии сети возвращает данные только из кэша и флаг `isOffline`.
3. Обновить экран “Мои записи”:
   - использовать `useOfflineBookings`;
   - добавить баннеры/статы по оффлайн‑режиму.

Это даст базовый, но полезный оффлайн‑режим без сложной двухсторонней синхронизации. При необходимости в будущем можно расширить его до полного оффлайна для создания/отмены броней с очередью операций, по аналогии с уже реализованным подходом для staff‑смен.

