## Обзор

Документ описывает текущие проблемы системы рейтингов в Kezek (сотрудники, филиалы, бизнесы), предлагаемые решения и конкретный план задач для реализации фиксoв.

Основано на:
- SQL‑миграциях `create_rating_system`, `create_rating_functions`, `improve_rating_calculation_for_inactive_periods`, `initialize_ratings`
- cron‑эндпоинте `/api/cron/recalculate-ratings`
- админ‑эндпоинтах `/api/admin/ratings/status`, `/api/admin/initialize-ratings`, `/admin/api/rating-config`
- документации `SYSTEM_FEATURES_DOCUMENTATION.md`

---

## 1. Проблема: “Пустые” дни всё равно попадают в метрики и занижают рейтинг

**Суть проблемы**

- В документации (`SYSTEM_FEATURES_DOCUMENTATION.md`, 1.6.5) описано, что дни без активности (нет смен, нет клиентов) **не должны попадать** в `*_day_metrics` и не должны влиять на агрегированный рейтинг.
- В реальном коде:
  - `recalculate_ratings_for_date` проходит по **всем активным** сотрудникам/филиалам/бизнесам и всегда вызывает `calculate_*_day_metrics(...)` для указанной даты.
  - `calculate_staff_day_metrics` всегда делает `insert ... on conflict` в `staff_day_metrics` даже при 0 клиентов, 0 отзывов и 0 смен.
- В результате:
  - дни “полного простоя” превращаются в записи с низким `day_score` (примерно 20 из 100),
  - эти дни входят в окно расчёта и **искусственно занижают** итоговый рейтинг.

**Предлагаемое решение**

1. Внести в `calculate_staff_day_metrics` (и при необходимости в branch/biz‑метрики) явную проверку “есть ли активность за день”:
   - нет ни одной подтверждённой/оплаченной записи,
   - нет смен с данными,
   - нет отзывов.
2. Если активности нет — **не создавать/не обновлять** строку в `staff_day_metrics` для этой даты (в том числе не затирать существующую строку нулями).
3. Аналогично скорректировать `calculate_branch_day_metrics` и `calculate_biz_day_metrics`, чтобы они агрегировали только те дни, где реально есть `staff_day_metrics`/`branch_day_metrics`.
4. Обновить документацию, чётко зафиксировав критерии “день считается активным”.

**Риски и эффекты**

- Переходный период: после деплоя часть “пустых” дней больше не будет попадать в новые расчёты, но уже записанные в БД нулевые/низкие дни останутся в истории до очередной инициализации/пересчёта.
- Нужен как минимум один раз прогнать пересчёт за последние N дней, чтобы очистить “грязную” историю.

---

## 2. Проблема: неочевидная семантика `rating_score = 0` и поведения при неактивности

**Суть проблемы**

- В логике инициализации и health‑чека `rating_score = 0` трактуется как “нет рейтинга”:
  - `initialize_all_ratings` выставляет стартовый рейтинг 50.0 для всех, у кого `rating_score IS NULL OR rating_score = 0`.
  - `/api/admin/ratings/status` считает “без рейтинга” все сущности, у которых `rating_score IS NULL OR rating_score = 0`.
- В улучшенных функциях `calculate_*_rating`:
  - при отсутствии метрик в окне берётся **последний сохранённый рейтинг** или **дефолт 50.0**.
- В документации есть формулировки, что при долгой неактивности рейтинг может “упасть до 0”.

**Проблема**

- Фактически:
  - “0” используется как маркер “нет рейтинга/не инициализировано”, а не как “самый плохой рейтинг”.
  - Поведение при неактивности теперь стремится **сохранить старый рейтинг или 50.0**, а не “сползать к нулю”.
- Это создаёт путаницу между:
  - бизнес‑ожиданиями (“0 = очень плохо”),
  - технической реализацией (“0 = пустое значение/ошибка инициализации”),
  - текстами документации.

**Предлагаемое решение**

1. Явно договориться о семантике:
   - `NULL` — “рейтинг не рассчитывался ни разу”.
   - `50.0` — дефолтный стартовый рейтинг.
   - `0.0`–`100.0` — реальное значение рейтинга (включая возможность честного `0.0`).
2. В коде:
   - заменить проверки вида `rating_score IS NULL OR rating_score = 0` на:
     - для “нет рейтинга”: только `IS NULL`;
     - для health‑чека добавить отдельное поле, если нужно отслеживать “подозрительные нулевые рейтинги”.
3. В документации переписать раздел 1.6.5:
   - убрать формулировки “упасть до 0 за долгую неактивность”,
   - явно описать, что при отсутствии активности мы **сохраняем последний рейтинг** или стартовый 50.0, чтобы не штрафовать отпуск/каникулы.
4. В UI админ‑панели:
   - показывать для `NULL` явное состояние “рейтинг не инициализирован”,
   - для реальных 0–10 подсвечивать как “низкий рейтинг”, но не смешивать это с техническим “нет рейтинга”.

---

## 3. Проблема: тяжёлая и потенциально опасная инициализация/исторический пересчёт

**Суть проблемы**

- Функции `recalculate_ratings_for_date_range` и `initialize_all_ratings`:
  - проходят по **всем** сотрудникам/филиалам/бизнесам для каждой даты в диапазоне,
  - не фильтруют по `is_active` / `is_approved`,
  - при большом окне (`days_back`) и большом количестве сущностей могут работать очень долго и создавать серьёзную нагрузку на Supabase.
- HTTP‑роут `POST /api/admin/initialize-ratings`:
  - принимает `days_back` без верхнего ограничения и напрямую прокидывает в RPC.

**Предлагаемое решение**

1. В `initialize_all_ratings` и `recalculate_ratings_for_date_range`:
   - ограничить объём сущностей фильтрами: только `staff.is_active = true`, `branches.is_active = true`, `businesses.is_approved = true`.
   - по возможности обрабатывать сущности батчами (например, по 500–1000 штук за один проход) или отдельными вызовами из крона/скриптов, а не монолитным большим циклом.
2. В `POST /api/admin/initialize-ratings`:
   - ввести валидируемый диапазон `days_back` (например, 1–365),
   - по умолчанию оставить 30, но явно подсвечивать в UI, если админ пытается запросить очень большой диапазон (предупреждение о длительности операции).
3. В документации:
   - добавить явное предупреждение, что “полная инициализация на большой истории” — тяжёлая операция, рекомендовать запускать её в off‑peak время и с разумным `days_back`.

---

## 4. Проблема: недостаточная наблюдаемость и инструменты для точечного дебага

**Суть проблемы**

- Сейчас есть только агрегированный health‑чек `/api/admin/ratings/status`:
  - показывает последние даты метрик и количество сущностей без рейтинга.
- Если cron `/api/cron/recalculate-ratings` частично падает:
  - PL/pgSQL функции пишут `raise warning`, но нет удобного способа увидеть “по каким именно staff/branch/biz расчёт ломается” внутри приложения.
  - нет инструмента для точечного пересчёта “только для этого сотрудника/филиала”.

**Предлагаемое решение**

1. Добавить диагностический admin‑эндпоинт вида `/api/admin/ratings/debug-entities`:
   - возвращает список сотрудников/филиалов/бизнесов:
     - с `rating_score IS NULL`,
     - у которых нет метрик за последние N дней,
     - с последним `day_score` подозрительно низким или вовсе отсутствующим.
2. Добавить admin‑действия:
   - “пересчитать рейтинг сотрудника X за последние N дней” (вызов `calculate_staff_day_metrics` в диапазоне + `calculate_staff_rating`),
   - аналогично для филиала/бизнеса.
3. В cron‑функции `recalculate_ratings_for_date`:
   - вместо простого `raise warning` дополнительно писать агрегированные ошибки в техтаблицу `rating_recalc_errors` (id сущности, тип, дата, текст ошибки), чтобы их можно было посмотреть из UI.

---

## 5. Проблема: смена конфигурации весов не сопровождается пересчётом истории

**Суть проблемы**

- При `POST /admin/api/rating-config`:
  - деактивируются старые записи в `rating_global_config`,
  - вставляется новая активная конфигурация с новыми весами и `window_days`.
- Агрегированные рейтинги в окне (30 дней по умолчанию) начинают учитывать:
  - старые `day_score`, посчитанные по старым весам,
  - новые `day_score`, посчитанные по новым весам.
- Документация упоминает, что для полного пересчёта истории нужно вызывать `recalculate_ratings_for_date_range`, но:
  - это не автоматизировано,
  - легко забыть сделать после изменения весов.

**Предлагаемое решение**

1. В UI страницы настройки рейтинга (`/admin/rating-config`):
   - после успешного сохранения новой конфигурации:
     - явно предложить администратору запустить пересчёт истории за последние N дней (например, 30/60/90),
     - или явно записать, что “история не была пересчитана” (и что это значит).
2. При необходимости — добавить опциональный флаг в `POST /admin/api/rating-config`:
   - `recalculate_history: boolean`,
   - если `true` — после вставки конфигурации триггерить вызов `initialize_all_ratings` или `recalculate_ratings_for_date_range` с ограниченным диапазоном (через очередь/фоновые задачи, а не в том же HTTP‑запросе).
3. В документации:
   - описать сценарий “сменили веса → что делать с историей и когда это нужно”.

---

## 6. План задач по фиксам

Ниже — чек‑лист задач, сгруппированный по темам. Идентификаторы можно использовать в PR и задачах трекера.

### 6.1. Логика активных/пустых дней

- [x] **RATING-ACTIVITY-1**: Добавить в `calculate_staff_day_metrics` проверку “есть ли активность за день” и не создавать запись в `staff_day_metrics` при полном отсутствии активности.
- [x] **RATING-ACTIVITY-2**: Убедиться, что `calculate_branch_day_metrics` и `calculate_biz_day_metrics` агрегируют только реально существующие метрики (`*_day_metrics`), а не создают “пустые” дни сами по себе.
- [x] **RATING-ACTIVITY-3**: Добавить отдельный сценарий/скрипт пересчёта метрик за последние N дней с учётом нового правила (чтобы убрать из истории старые “пустые” дни).
- [x] **RATING-ACTIVITY-4**: Обновить раздел 1.6.5 в `SYSTEM_FEATURES_DOCUMENTATION.md`, описав точные критерии “активного дня”.

### 6.2. Семантика `rating_score` и неактивность

- [x] **RATING-SEMANTICS-1**: Зафиксировать в документации (отдельный подпункт в разделе про рейтинги) семантику `NULL` / `50.0` / диапазона 0–100.
- [x] **RATING-SEMANTICS-2**: В `initialize_all_ratings` и health‑чеке `/api/admin/ratings/status` перестать использовать `rating_score = 0` как признак “нет рейтинга”; ориентироваться на `IS NULL`, либо завести отдельное диагностическое поле.
- [x] **RATING-SEMANTICS-3**: Переписать текст в `SYSTEM_FEATURES_DOCUMENTATION.md` про “рейтинг может упасть до 0 при долгой паузе”, приведя его в соответствие с текущей логикой (сохранение последнего рейтинга/дефолта).
- [x] **RATING-SEMANTICS-4**: В UI (там, где показывается рейтинг) отразить различие между “не инициализирован” (NULL) и “очень низкий рейтинг” (0–10).

### 6.3. Производительность и безопасность инициализации/пересчёта

- [x] **RATING-INIT-1**: В `initialize_all_ratings` и `recalculate_ratings_for_date_range` добавить фильтры по `is_active` / `is_approved`, чтобы не считать рейтинги для неактивных сущностей.
- [x] **RATING-INIT-2**: Ограничить `days_back` в `POST /api/admin/initialize-ratings` (например, диапазон 1–365) и добавить валидацию с понятной ошибкой.
- [x] **RATING-INIT-3**: Задокументировать рекомендованные значения `days_back` и режим запуска (off‑peak время) в `APPLY_MIGRATIONS.md` или отдельном админ‑гайде.
- [x] **RATING-INIT-4**: (Опционально) продумать и реализовать батчевую/фонoвую версию `initialize_all_ratings` для очень больших баз.

### 6.4. Наблюдаемость и дебаг

- [x] **RATING-OBSERVE-1**: Добавить таблицу `rating_recalc_errors` и писать туда id сущности, дату, тип сущности и текст ошибки из `recalculate_ratings_for_date`.
- [x] **RATING-OBSERVE-2**: Реализовать admin‑эндпоинт `/api/admin/ratings/debug-entities`, который показывает:
  - сущности с `rating_score IS NULL`,
  - сущности без метрик за последние N дней,
  - при необходимости — последние ошибки из `rating_recalc_errors`.
- [x] **RATING-OBSERVE-3**: Добавить на `/admin/ratings-status` ссылку/кнопку на новый debug‑экран.

### 6.5. Управление конфигурацией весов

- [x] **RATING-CONFIG-1**: В `RatingConfigClient` (страница `/admin/rating-config`) добавить UX после сохранения:
  - “Вы изменили веса. Хотите пересчитать историю за последние N дней?” (с выбором N).
- [x] **RATING-CONFIG-2**: Добавить опциональный флаг `recalculate_history` (или отдельный эндпоинт) для запуска исторического пересчёта после смены конфигурации.
- [x] **RATING-CONFIG-3**: Обновить `SYSTEM_FEATURES_DOCUMENTATION.md`, явно описав сценарий смены весов и пересчёта истории.

### 6.6. Сквозные E2E-сценарии и UX админки

- [x] **RATING-E2E-1**: Добавить E2E-сценарий, который проходит полный админский флоу:
  - проверка текущего статуса рейтингов (`/admin/ratings-status`),
  - переход на страницу настроек (`/admin/rating-config`), изменение конфигурации и сохранение,
  - запуск исторического пересчёта (через существующий механизм в UI),
  - ожидание завершения пересчёта и повторная проверка `/admin/ratings-status`,
  - переход на debug‑экран (`/admin/ratings-debug` или аналогичный) и проверка, что критичных проблем нет.
- [x] **RATING-E2E-2**: При необходимости выделить фикстуру/seed‑сценарий для E2E‑теста рейтингов, чтобы он был детерминированным и не зависел от случайного состояния базы.

### 6.7. Усиленная observability и cron-операции рейтингов

- [x] **RATING-CRON-OBS-1**: Для cron‑эндпоинта `/api/cron/recalculate-ratings` добавить:
  - явные метрики длительности и количества пересчитанных сущностей,
  - счётчик ошибок и предупреждений (в том числе на основе `rating_recalc_errors`),
  - логирование ключевых параметров запуска (дата/диапазон/фильтры).
- [x] **RATING-CRON-OBS-2**: Убедиться, что cron‑пересчёт рейтингов идемпотентен:
  - повторный запуск за тот же диапазон дат не приводит к “дублирующим” или конфликтующим записям (используются уникальные ключи + `insert ... on conflict do update` в `*_day_metrics`),
  - ошибки отдельных сущностей не ломают весь батч (каждый вызов `calculate_*` обёрнут в `exception when others` с записью в `rating_recalc_errors` и `raise warning`).

### 6.8. TS-домен и тесты инвариантов рейтингов

- [x] **RATING-DOMAIN-1**: Выделить тонкий TS‑доменный слой для рейтингов (хотя бы на уровне типов и pure‑хелперов), который:
  - явно кодирует семантику `NULL` / `50.0` / 0–100 (см. `@shared-client/rating`: `interpretRatingScore`, `isRatingUninitialized`, `isDefaultRating`),
  - описывает инварианты окон (какие дни попадают, какие нет) (`getRatingWindow`, `isDateInRatingWindow`, `isActiveStaffDay`),
  - минимизирует дублирование этой логики по API‑роутам и UI (хелперы доступны из web и mobile через `@shared-client`).
- [x] **RATING-DOMAIN-2**: Добавить unit/integration‑тесты поверх TS‑слоя, которые проверяют:
  - корректную работу с “пустыми” днями (`ratingDomain.test.ts` → `isActiveStaffDay`),
  - ожидаемое поведение при длительной неактивности (`getRatingWindow` / `isDateInRatingWindow` с исключением текущего дня),
  - согласованность с описанием в `SYSTEM_FEATURES_DOCUMENTATION.md` (семантика `NULL` / `50.0` / 0–100 через `interpretRatingScore` и друзья).

---

## 7. Как использовать этот документ

- **Для планирования**: брать задачи из блоков 6.1–6.5, начиная с:
  - `RATING-ACTIVITY-*` (логика активных дней),
  - `RATING-SEMANTICS-*` (семантика рейтингов),
  - затем переходить к инициализации и наблюдаемости.
- **Для PR**: в описании указывать id задачи (например, `RATING-ACTIVITY-1`) и коротко фиксировать, что именно было изменено.
- **Для документации**: поддерживать этот файл в актуальном состоянии синхронно с изменениями SQL/кода/админ‑UI.

